<!doctype html><html xmlns="http://www.w3.org/1999/xhtml"><head prefix="og: http://ogp.me/ns# fb: http://ogp.me/ns#"><script>var loc = new String(window.location); if (loc.indexOf('facebook.github.io/buck') != -1) {window.location.replace(loc.replace('facebook.github.io/buck', 'buckbuild.com'));}</script><!-- Facebook Pixel Code --><script>!function(f,b,e,v,n,t,s){if(f.fbq)return;n=f.fbq=function(){n.callMethod?n.callMethod.apply(n,arguments):n.queue.push(arguments)};if(!f._fbq)f._fbq=n;n.push=n;n.loaded=!0;n.version='2.0';n.queue=[];t=b.createElement(e);t.async=!0;t.src=v;s=b.getElementsByTagName(e)[0];s.parentNode.insertBefore(t,s)}(window,document,'script','//connect.facebook.net/en_US/fbevents.js'); fbq('init', '1637165926500152'); fbq('track', 'PageView');</script><noscript><img height="1" width="1" style="display:none" src="https://www.facebook.com/tr?id=1637165926500152&ev=PageView&noscript=1" /></noscript><!-- End Facebook Pixel Code --><title>Buck: buck query</title><link type="image/png" rel="shortcut icon" href="/static/favicon.png" /><meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no" /><meta http-equiv="content-type" content="text/html;charset=utf-8"><link type="text/css" rel="stylesheet" href="/google-code-prettify/prettify.css" ><link type="text/css" rel="stylesheet" href="/static/buck.css"><link type="text/css" rel="stylesheet" href="/static/search.css"><link type="text/css" rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css" /><meta property="og:locale" content="en_US"><meta property="og:title" content="buck query"><meta property="og:site_name" content="Buck: a build tool"><meta property="og:image" content="http://buckbuild.com/static/og.png"><meta property="og:type" content="article"><meta property="og:description" content="Provide facilities to query information about the target-nodes graph."><meta property="fb:admins" content="584556688222168"><script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-44373548-18', 'auto');
    ga('send', 'pageview');
  </script></head><body><div id="fb-root"></div><script>(function(d, s, id) {var js, fjs = d.getElementsByTagName(s)[0]; if (d.getElementById(id)) return; js = d.createElement(s); js.id = id; js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=584556688222168"; fjs.parentNode.insertBefore(js, fjs);}(document, 'script', 'facebook-jssdk'));</script><header class='topbar'><nav class='width'><a href='http://buckbuild.com/'><h1>Buck</h1></a><ul class='menu'><li class="algolia-search-wrapper"><input id="algolia-doc-search" type="search" placeholder="Search docs..." /></li><li><a href='/setup/getting_started.html'>Docs</a><li><a href='https://github.com/facebook/buck/issues'>Issues</a><li><a href='https://github.com/facebook/buck'>GitHub</a></ul></nav></header><section class='content'><div class='width'><article id="content"><h1>buck query</h1><div class="overview"><p>The <code>buck query</code> command provides functionality to query the <em>target-nodes</em> graph and return the build targets that satisfy your query expression.</p><p>The query language implemented in <code>buck query</code>, enables you to combine multiple operators in a single command. For example, to retrieve a list of all the tests for a build target, you can combine the <code>deps()</code> and <code>testsof()</code> operators into a single call to <code>buck query</code>.</p><p><pre>
buck query "testsof(deps('//java/com/example/app:amazing'))"
</pre></p><h2>Query Language</h2><p>The Buck query language was inspired by the <a href="http://bazel.io/docs/query.html"> Bazel Query Language</a>. The Buck query language uses the same parser, so the lexical syntax is similar. The Buck query language supports a subset of Bazel's query functionality with a few extensions, such as <code>attrfilter</code>, <code>inputs</code>, and <code>owner</code>.</p><h3>Lexical Syntax</h3><p>Expressions in the query language are composed of the following tokens:</p><ul><li><b>Keywords</b>, such as <code>deps</code> or <code>testsof</code>. Keywords are the reserved words of the language. The complete set of keywords is:<ul style="line-height:0.5em"><li><a href="#allpaths"><code>allpaths</code></a>: All dependency paths</li><li><a href="#attrfilter"><code>attrfilter</code></a>: Rule attribute filtering</li><li><a href="#buildfile"><code>buildfile</code></a>: Build files of targets</li><li><a href="#deps"><code>deps and first-order-deps</code></a>: Transitive closure of dependencies</li><li><a href="#set-operations"><code>except</code></a>: Set difference</li><li><a href="#filter"><code>filter</code></a>: Filter targets by name</li><li><a href="#inputs"><code>inputs</code></a>: Direct input files</li><li><a href="#set-operations"><code>intersect</code></a>: Set intersection</li><li><a href="#kind"><code>kind</code></a>: Filter targets by rule type</li><li><a href="#labels"><code>labels</code></a>: Extract content of rule attributes</li><li><a href="#owner"><code>owner</code></a>: Find targets that own specified files</li><li><a href="#rdeps"><code>rdeps</code></a>: Transitive closure of reverse dependencies</li><li><a href="#set"><code>set</code></a>: Group targets</li><li><a href="#testsof"><code>testsof</code></a>: List the tests of the specified targets</li><li><a href="#set-operations"><code>union</code></a>: Set union</li></ul></li><li><p><b>Words</b>, such as <code>//foo:bar</code> and <code>//foo:bar+lib"</code>. If a character sequence is "quoted", that is, it begins and ends with a single-quote (<code>'</code>), or begins and ends with a double-quote (<code>"</code>), it is always parsed as a word. If a character sequence is not quoted, it is still parsed as a word if it adheres to certain conditions: unquoted words are sequence of characters drawn from the set of alphabet characters, numerals, forward slash (<code>/</code>), colon (<code>:</code>), period (<code>.</code>), hyphen (<code>-</code>), underscore (<code>_</code>), and asterisk (<code>*</code>). Unquoted words may not start with a hyphen or period. This syntax makes quoting unnecessary in many cases. For example, quoting <code>"java_test"</code> is unnecessary.</p><p>Consider the following additional examples:<pre>
//foo:bar+wiz    # WRONG: scanned as //foo:bar + wiz.
//foo:bar=wiz    # WRONG: scanned as //foo:bar = wiz.
'//foo:bar+wiz'  # Okay.
'//foo:bar=wiz'  # Okay.
</pre></p><p>Note that quoting of words is in addition to any quoting that may be required by your shell. In the following example, double-quotes are used for the shell and single-quotes for the <code>build target</code> expression.<pre>
buck query " '//foo:bar=wiz' "
</pre></p><p>You should always use quotes when writing scripts that construct <code>buck query</code> expressions <em>from user-supplied values</em>.</p></li><li><b>Punctuation</b>, such as parentheses (<code>()</code>), period (<code>.</code>) and comma (<code>,</code>), etc. Words containing punctuation&mdash;other than the exceptions listed above under <b>Words</b>&mdash;must be quoted.</li></ul><p>Whitespace characters outside of a quoted word are ignored.</p><h3>Expressions: syntax and semantics of the grammar</h3><p>This is the grammar of the query language, expressed in Extended Backus Naur Form (<a href="https://en.wikipedia.org/wiki/Extended_Backus-Naur_Form">EBNF</a>) notation:</p><pre>
expr ::= word
       | (expr)
       | expr intersect expr
       | expr ^ expr
       | expr union expr
       | expr + expr
       | expr except expr
       | expr - expr
       | allpaths(expr, expr)
       | attrfilter(word, word, expr)
       | buildfile(expr)
       | deps(expr)
       | deps(expr, depth)
       | deps(expr, depth, expr)
       | deps(expr, depth, first-order-deps(expr))
       | filter(word, expr)
       | inputs(expr)
       | kind(word, expr)
       | labels(word, expr)
       | owner(word)
       | rdeps(expr, expr)
       | rdeps(expr, expr, depth)
       | set(word *)
       | testsof(expr)
</pre><h4>Target Patterns</h4><p><pre>expr ::= word</pre></p><p>Syntactically, a <a href="/concept/build_target_pattern.html">build target pattern</a>, or build target <em>expression</em>, is just a word. A build target pattern evaluates to a set containing one or more elements. It is interpreted as an unordered set of targets.</p><p>For example, the word <code>//foo:bar</code> resolves to a set containing one build target, while <code>//foo/...</code> resolves to all targets in every directory beneath the </code>foo</code> directory.</p><h4>Aliases</h4><p><pre>expr ::= word</pre></p><p>Aliases defined in <a href="/files-and-dirs/buckconfig.html"><code>.buckconfig</code></a> can be used in queries. Aliases resolve to their corresponding build targets. Suppose there is the following alias</p><p><pre>
app = //apps/myapp:app
</pre></p><p>then <code>app</code> can be used instead of <code>//apps/myapp:app</code> in query expressions.</p><p>You can also use <code>buck query</code> to resolve aliases. For example:</p><p><pre>
$ buck query app
//apps/myapp:app
</pre></p><h4>Parenthesized expressions</h4><p><pre>expr ::= (expr)</pre></p><p>Parentheses associate sub-expressions to force an order of evaluation. A parenthesized expression resolves to the value of the expression it encloses.</p><h4 id="set-operations">Algebraic set operations: intersection, union, set difference</h4><p><p><pre>
expr ::= expr intersect expr
       | expr ^ expr
       | expr union expr
       | expr + expr
       | expr except expr
       | expr - expr
</pre></p><p>These three operators compute the corresponding set operations over their arguments. Each operator has two forms, a nominal form, such as <code>intersect</code>, and a symbolic form, such as <code>^</code>. Both forms are equivalent; the symbolic forms are just quicker to type. For example,</p><p><pre>buck query "deps('//foo:bar') intersect deps('//baz:lib')"</pre></p><p>and</p><p><pre>buck query "deps('//foo:bar') ^ deps('//baz:lib')"</pre></p><p>both return the targets that appear in the transitive closure of <code>//foo:bar</code> and <code>//baz:lib</code>.</p><p>The <code>intersect</code> (<code>^</code>) and <code>union</code> (<code>+</code>) operators are commutative (symmetric); however, the <code>except</code> (<code>-</code>) operator is asymmetric.</p><p>The parser treats all three operators as left-associative and of equal precedence, so we strongly recommend that you use parentheses if you need to ensure a specific order of evaluation. For example, the first two expressions are equivalent, but the third is not:</p><p><pre>
x intersect y union z
(x intersect y) union z
x intersect (y union z)
</pre></p><h4 id="set">Group targets: set</h4><p><p><b>Semantics</b><pre>
<code>set(<em>a</em> <em>b</em> <em>c</em> ...)</code> 
</pre></p><p><b>Syntax</b><pre>
expr ::= set(expr *)
</pre></p><p>The <code>set(<em>a</em> <em>b</em> <em>c</em> ...)</code> operator computes the union of a set of zero or more targets, separated by white space (no commas). Quote the targets to ensure that they are parsed correctly.</p><p><b>Example:</b></p><p>The following expression returns the merged set (union) of dependencies for the targets: <code>:main</code> and <code>:myclass</code>.</p><p><pre>
buck query "deps( set( ':main' ':myclass' ) )"
</pre></p><p>If you invoke <code>buck query</code> programmatically, such as to run a query on a list of targets, then <code>set()</code> is a way to group this list in the query.</p><h4 id="allpaths">All dependency paths: allpaths</h4><p><p><b>Semantics</b><pre>
allpaths(<em>from</em>, <em>to</em>)
</pre></p><p><b>Syntax</b><pre>
expr ::= allpaths(expr, expr)
</pre></p><p>The <code>allpaths(<em>from</em>, <em>to</em>)</code> operator evaluates to the graph formed by paths between the sets <code>from</code> and <code>to</code>, following the dependencies between nodes. For example, the value of<p><pre>
buck query "allpaths('//foo:bar', '//foo/bar/lib:baz')"
</pre><p>is the dependency graph rooted at the single target node <code>//foo:bar</code>, that includes all target nodes that depend on <code>//foo/bar/lib:baz</code>.</p><p>The two arguments to <code>allpaths()</code> can themselves be expressions. For example, the command:<p><pre>
buck query "allpaths(kind(java_library, '//...'), '//foo:bar')"
</pre></p>shows all the paths between any <code>java_library</code> in the repository and the target <code>//foo:bar</code>.</p><p>We recommend using <code>allpaths()</code> with the <code>--dot</code> parameter to generate a graphviz file that can then be rendered as an image. For example:</p><p><pre class="prettyprint lang-py">
$ buck query "allpaths('//foo:bar', '//foo/bar/lib:baz')" --dot > result.dot
$ dot -Tpng result.dot -o image.png
</pre></p><p><em>Graphviz</em> is an open-source graph-visualization software tool. Graphviz uses the <em>dot</em> language to describe graphs.</p><h4 id="attrfilter">Rule attribute filtering: attrfilter</h4><p><p><b>Semantics</b><pre>
attrfilter(<em>attribute</em>, <em>value</em>, <em>expression</em>)
</pre></p><p><b>Syntax</b><pre>
expr ::= attrfilter(word, word, expr)
</pre></p><p>The <code>attrfilter(<em>attribute</em>, <em>value</em>, <em>expression</em>)</code> operator evaluates the given <code><em>expression</em></code> and filters the resulting build targets for those where the specified <code><em>attribute</em></code> contains the specified <code><em>value</em></code>.</p><p>In this context, the term <em>attribute</em> refers to an argument in a build rule, such as <code>name</code>, <code>headers</code>, <code>srcs</code>, or <code>deps</code>.</p><p>If the attribute is a single value, say <code>name</code>, it is compared to the specified <code><em>value</em></code>, and the target is returned if they match. If the attribute is a list, the target is returned if that list contains the specified <code><em>value</em></code>. If the attribute is a dictionary, the target is returned if the <code><em>value</em></code> exists in either the keys or the values of the dictionary.</p><p>For example,<p><p><pre>
buck query "attrfilter(deps, '//foo:bar', '//...')"
</pre></p><p>returns the build targets in the repository that depend on <code>//foo:bar</code>&mdash;or more precisely: those build targets that include <code>//foo:bar</code> in their <code>deps</code> argument list.</p><p>The match performed by <code>attrfilter()</code> is semantic rather than textual. So, for example, if you have the following <code>deps</code> argument in your build file:<p><pre>
cxx_binary(
  name = 'main',
  srcs = [
    'main.cpp'
  ],
  deps = [
    ':myclass',
  ],
)
</pre></p><p>Your <code>attrfilter()</code> clause should be:</p><p><pre>
buck query "attrfilter( deps, '//:myclass', '//...' )"
</pre></p><p>Note the double forward slash (<code>//</code>) before the second argument to <code>attrfilter()</code>.</p><h4 id="buildfile">Build files of targets: buildfile</h4><p><p><b>Semantics</b><pre>
buildfile(<em>expression</em>)
</pre></p><p><b>Syntax</b><pre>
expr ::= buildfile(expr)
</pre></p><p>The <code>buildfile(expression)</code> operator evaluates to those build files that define the targets that result from the evaluation of <code>expression</code>.</p><p>In order to find the build file associated with a source file, combine the <code>owner</code> operator with <code>buildfile</code>. For example,</p><p><pre>
buck query "buildfile(owner('foo/bar/main.cpp'))" 
</pre></p><p>first finds the targets that <em>own</em> <code>foo/bar/main.cpp</code> and then returns the build files, such as <code>foo/bar/BUCK</code>, that define those targets.</p><h4 id="deps">Transitive closure of dependencies: deps and first-order-deps</h4><p><p><b>Semantics</b><pre>
deps(<em>x</em>)
deps(<em>x</em>, <em>integer</em>)
deps(<em>x</em>, <em>integer</em>, <em>y</em>)
deps(<em>x</em>, <em>integer</em>, first_order_deps(<em>y</em>))
</pre></p><p><b>Syntax</b><pre>
expr ::= deps(expr)
       | deps(expr, depth)
       | deps(expr, depth, expr)
       | deps(expr, depth, first_order_deps(expr))
</pre></p><p>The <code>deps(<em>x</em>)</code> operator evaluates to the graph formed by the transitive closure of the dependencies of its argument set, <i>x</i>, including the nodes from the argument set itself. For example, the value of</p><p><pre>
buck query "deps('//foo:bar')" 
</pre></p><p>is the dependency graph rooted at the target node <code>//foo:bar</code>. It includes all of the dependencies of <code>//foo:bar</code>. It also includes <code>//foo:bar</code> itself.</p><p>The <code>deps</code> operator accepts an optional second argument, which is an integer literal specifying an upper bound on the depth of the search.  So,</p><p><pre>
deps('//foo:bar', 1) 
</pre></p><p>evaluates to the direct dependencies of the target <code>//foo:bar</code>, and</p><p><pre>
deps('//foo:bar', 2) 
</pre></p><p>further includes the nodes directly reachable from the nodes in <code>deps('//foo:bar', 1)</code>, and so on. If the depth parameter is omitted, the search is unbounded, that is, it computes the entire transitive closure of dependencies.</p><h4>Filter expressions and first_order_deps()</h4><p>The <code>deps()</code> operator also accepts an optional third argument, which is a filter expression that is evaluated for each node and returns the child nodes to recurse on when collecting transitive dependencies.</p><p>This filter expression can use the <code>first_order_deps()</code> operator which returns a set that contains the first-order dependencies of the current node&mdash;which is equivalent to <code>deps(&lt;node&gt;, 1)</code>. For example, the query,</p><p><pre>
buck query "deps('//foo:bar', 1, first_order_deps())"
</pre></p><p>is equivalent to</p><p><pre>
buck query "deps('//foo:bar', 1)"
</pre></p><p>The <code>first_order_deps()</code> operator can be used only inside the expression passed as an argument to <code>deps()</code>.<p><p>Note that because <code>deps()</code> uses positional parameters, you must specify the second argument in order to specify the third. In this scenario, if you want the search to be unbounded, we recommend that you use <code>2147483647</code> which corresponds to Java's <code>Integer.MAX_VALUE</code>.</p><h4 id="filter">Filter targets by name: filter</h4><p><p><b>Semantics</b><pre>
filter(<em>pattern</em>, <em>expression</em>)
</pre></p><p><b>Syntax</b><pre>
expr ::= filter(word, expr)
</pre></p><p>The <code>filter(<em>pattern</em>, <em>expression</em>)</code> operator evaluates the specified <code><em>expression</em></code> and returns the targets that have a name attribute that matches the specified regular expression <code><em>pattern</em></code>. For example,<p><pre>
buck query "filter('library', deps('//foo:bar'))"
</pre></p><p>returns the targets in the transitive closure of <code>//foo:bar</code>that contain the string  <code>library</code> in their name attribute.</p><p>The <code>filter()</code> operator performs a <em>partial</em> match. So, both of the following clauses would match a target with the name <code>main</code>.<p><pre>
buck query "filter( 'main', '//...' )"
</pre></p><p><pre>
buck query "filter( 'mai', '//...' )"
</pre></p><p>Another example:</p><pre>
buck query "filter('.*\.java$', labels(srcs, '//foo:bar'))"
</pre></p><p>returns the <code>java</code> files used to build <code>//foo:bar</code>.</p><p>You often need to quote the pattern to ensure that regular expressions, such as <code>.*xpto</code>, are parsed correctly.</p><h4 id="inputs">Direct input files: inputs</h4><p><p><b>Semantics</b><pre>
inputs(<em>x</em>)
</pre></p><p><b>Syntax</b><pre>
expr ::= inputs(expr)
</pre></p><p>The <code>inputs(x)</code> operator returns the files that are inputs to the argument set <i>x</i>, ignoring all dependencies. Note that it does not include any files required for parsing, such as the BUCK file. Rather, it returns only the files required to actually run the build after parsing has been performed.</p><p>Note that <code>input()</code> returns only those input files indicated by the <em>target graph</em>. Input files that are present in the <em>action graph</em> but not in the target graph are not returned by <code>input()</code>.</p><p>You could consider the <code>inputs()</code> and <code>owner()</code> operators to be inverses of each other.</p><h4 id="kind">Filter targets by rule type: kind</h4><p><p><b>Semantics</b><pre>
kind(<em>pattern</em>, <em>expression</em>)
</pre></p><p><b>Syntax</b><pre>
expr ::= kind(word, expr)
</pre></p><p>The <code>kind(<em>pattern</em>, <em>expression</em>)</code> operator evaluates the specified  <code>expression</code> and returns the targets where the rule type matches the specified <code>pattern</code>. For example,</p><p><pre>
buck query "kind('java_library', deps('//foo:bar'))"
</pre></p><p>returns all <code>java_library</code> targets in the transitive dependencies of <code>//foo:bar</code>.</p><p>The specified <em>pattern</em> can be a regular expression. For example,</p><p><pre>
buck query "kind('.*_test', '//...')"
</pre></p><p>returns all targets in the repository with a rule type that ends with <code>_test</code>, such as <code>java_test</code> and <code>cxx_test</code>.</p><p>You often need to quote the pattern to ensure that regular expressions, such as <code>.*xpto</code>, are parsed correctly.</p><p>To get a list of the available rule types in a given set of targets, you could use a command such as the following:</p><p><pre>
buck query : --output-attribute buck.type
</pre></p><p>which prints all the rule types in the build file in the current directory (<code>:</code>)&mdash;in JSON format. See <code>--output-attribute</code> described in the <b>Parameters</b> section below for more information.</p><h4 id="labels">Extract content of rule attributes: labels</h4><p><p><b>Semantics</b><pre>
labels(<em>name</em>, <em>expression</em>)
</pre></p><p><b>Syntax</b><pre>
expr ::= labels(word, expr)
</pre></p><p>The <code>labels(<em>name</em>, <em>expression</em>)</code> operator returns the set of build targets and file paths listed in the attribute specified by the <em>name</em> parameter, in the targets that result from the evaluation of <em>expression</em>. Valid values for <em>name</em> include <code>srcs</code>, <code>headers</code>, and <code>deps</code>.</p><p><b>Example</b>: Get all build targets and file paths specified in the <code>srcs</code> attribute for <em>all the rules</em> in the build file in the current directory.</p><p> <pre>
buck query "labels( 'srcs', ':' )"
</pre></p><p>In performing this operation, Buck validates that any source files referenced in these attributes do, in fact, exist; Buck generates an error if they do not.</p><p><b>Example</b>: Get all the build targets and file paths specified in the <code>deps</code> arguments in the <em>tests of</em> the target <code>//foo:bar</code>.</p><p> <pre>
buck query "labels('deps', testsof('//foo:bar'))"
</pre></p><p>Note that <code>deps</code> must be quoted because, in addition to being a build-file attribute, it is itself a reserved keyword of the query language.</p><h4 id="owner">Find targets that own specified files: owner</h4><p><p><b>Semantics</b><pre>
owner(<em>file</em>)
</pre></p><p><b>Syntax</b><pre>
expr ::= owner(word)
</pre></p><p>The <code>owner(<em>file</em>)</code> operator returns the targets that own the specified <em>file</em>. In this context, <em>own</em> means that the target has the specified file as an input. You could consider the <code>owner()</code> and <code>inputs()</code> operators to be inverses of each other.</p><p><b>Example</b>:</p><p><pre>
buck query "owner('examples/1.txt')"
</pre></p><p>returns the targets that owns the file <code>examples/1.txt</code>, which could be a value such as <code>//examples:one</code>.</p><p>It is possible for the specified file to have multiple owners, in which case, <code>owner()</code> returns a set of targets.</p><p>If no owner for the file is found, <code>owner()</code> outputs the message:<pre>
No owner was found for &lt;file&gt;
</pre></p><h4 id="rdeps">Transitive closure of reverse dependencies: rdeps</h4><p><p><b>Semantics</b><pre>
rdeps(<em>u</em>, <em>x</em>)</code> 
</pre></p><p><b>Syntax</b><p><pre>
expr ::= rdeps(expr, expr)
       | rdeps(expr, expr, depth)
</pre></p><p>The <code>rdeps(u, x)</code> operator returns the reverse dependencies of the argument set <code>x</code> within the transitive closure of the set <code>u</code> (the <em>universe</em>). The returned values include the nodes from the argument set <code>x</code> itself.</p><p>The <code>rdeps</code> operator accepts an optional third argument, which is an integer literal specifying an upper bound on the depth of the search.</p><p>The following example,</p><p><pre>
buck query "rdeps('//foo:bar', '//example:baz', 1)"
</pre></p><p>returns the targets in the transitive closure of <code>//foo:bar</code> that depend directly on <code>//example:baz</code>.</p><p>If the <em>depth</em> parameter is omitted, the search is unbounded.</p><h4 id="testsof">List the tests of the specified targets: testsof</h4><p><p><b>Semantics</b><pre>
testsof(<em>expression</em>)
</pre></p><p><b>Syntax</b><pre>
expr ::= testsof(expr)
</pre></p><p>The <code>testsof(<em>expression</em>)</code> operator returns the tests associated with the targets specified by <em>expression</em>. For example,</p><p><pre>
buck query "testsof(set('//foo:bar' '//baz:app+lib')"
</pre></p><p>returns the tests associated with <code>//foo:bar</code> and <code>//baz:app+lib</code>.</p><p>To obtain all the tests associated with the target and its dependencies, you can combine the <code>testsof()</code> operator with the <code>deps()</code> operator. For example,</p><p><pre>
buck query "testsof(deps('//foo:bar'))"
</pre></p><p>first finds the transitive closure of <code>//foo:bar</code>, and then lists all the tests associated with the targets in this transitive closure.</p><h2>Executing multiple queries at once</h2><p>Suppose you want to know the tests associated with a set of targets. This can be done by combining the <code>testsof</code>, <code>deps</code> and <code>set</code> operators. For example,</p><p><pre>
buck query "testsof(deps(set('target1' 'target2' 'target3')))"
</pre></p><p>Suppose you now want to know the tests for <em>each</em> of these targets; the above command returns the union of the tests. Instead of executing one query for the entire set of targets, <code>buck query</code> provides a way to repeat a query with different targets using a single command. To do this, first define the query expression format and then list the input targets, separated by spaces. For example,</p><p><pre>
buck query "testsof(deps( %s ))" target1 target2 target3
</pre></p><p>The <code>%s</code> in the query expression is replaced by each of the listed targets, and for each target, the resulting query expression is evaluated. If you add the <code>--json</code> parameter, the result of the command is grouped by input target; otherwise, as in the previous example using <code>set()</code>, the command merges the results and returns the union of the queries.</p><p>This syntax is also useful for subcommands that take arguments that are not targets, such as <code>owner()</code>. Recall that the <code>set()</code> operator works only with targets, but the <code>owner()</code> operator takes a filename as its argument.</p><p><pre>
buck query "owner( %s )" main.cpp myclass.cpp myclass.h
</pre></p><h2>Referencing Args Files</h2><p>When running queries, arguments can be stored in external files, one argument per line, and referenced with the <code>@</code> symbol. This is convenient when the number of arguments is long or when you want to persist the query input in source control.</p><p><pre>buck query "testsof(deps(%s))" @/path/to/args-file</pre></p><p>If you want to include all the targets in the <code>@</code>-file in a single query execution, you can use the following alternative syntax. Note the addition of the capital "<code>S</code>" in "<code>%Ss</code>".</p><p><pre>buck query "testsof(deps(%Ss))" @/path/to/args-file</pre></p><p>In the example above, the lines of the file are converted to a set and substituted for the <code>%Ss</code>. In addition, each line's contents are singly quoted.  In the example above, if the args file contains the following:</p><p><pre>
//foo:bar
//foo:baz
</pre></p><p>Then the query expression is equivalent to:</p><p><pre>
buck query "testsof(deps(set('//foo:bar' '//foo:baz')))"
</pre></p><p>If you use multiple <code>%Ss</code> operators in a single query, you can specify which lines in the <code>@</code>-file should be used for each instance of <code>%Ss</code> in the query expression: use <code>--</code> to separate elements that go in different sets. For example:</p><p><pre>buck query "testsof(deps(%Ss)) union deps(%Ss)" @path/to/args-file</pre></p><p><pre>
//foo:foo
--
//bar:bar
</pre></p><p>is equivalent to running the following:</p><p><pre>buck query "testsof(deps(set('//foo:foo'))) union deps(set('//bar:bar'))"</pre></p><h2>Parameters</h2><ul class="arglist"><li class="arg"><code>--dot</code>  <p>Outputs the digraph representing the query results in <a href= "https://en.wikipedia.org/wiki/DOT_(graph_description_language)#Directed_graphs">dot format</a>. The nodes will be colored according to their type. See <a href="http://www.graphviz.org/doc/info/colors.html">graphviz.org</a> for color definitions.<p><pre class="prettyprint lang-py">
android_aar          : springgreen2
android_library      : springgreen3
android_resource     : springgreen1
android_prebuilt_aar : olivedrab3
java_library         : indianred1
prebuilt_jar         : mediumpurple1
</pre></p>Example usage:</p><p><pre class="prettyprint lang-py">
$ buck query "allpaths('//foo:bar', '//path/to:other')" --dot > graph.dot
$ dot -Tpng graph.dot -o graph.png
</pre></p><p>Then, open <code>graph.png</code> to visualize the graph.</p><li class="arg"><code>--json</code>  Outputs the results as JSON.<li class="arg"><code>--output-attributes &lt;attributes&gt;</code>  <div id="output-attributes"><p>Outputs the results as a JSON dictionary <code>build target -> attributes map</code>. The attributes map is a dictionary mapping the specified attributes to their values for the build target. Attributes are regular expressions (e.g. '.*' matches all attributes). If an attribute (e.g. <code>srcs</code>) is not defined for a build target, it is not present in the output.<br /><br />NOTE: There is ambiguity when using this option with '%s' style queries. It is suggested to use <code>--output-attribute</code> instead. Example:</p><p><pre class="prettyprint lang-py">
$ buck query '//example/...' --output-attributes buck.type name srcs
{
  "//example/foo:bar" : {
    "buck.type" : "cxx_library",
    "name" : "foobar",
    "srcs" : [ "example/foo/bar.cc", "example/foo/lib/lib.cc" ]
  }
  "//example/foo:main" : {
    "buck.type" : "cxx_binary",
    "name" : "main"
  }
}
</pre></p></div><li class="arg"><code>--output-attribute &lt;attribute&gt;</code>  <div id="output-attributes"><p>Outputs the results as a JSON dictionary <code>build target -> attributes map</code>. The attributes map is a dictionary mapping the specified attributes to their values for the build target. Attributes are regular expressions (e.g. '.*' matches all attributes). If an attribute (e.g. <code>srcs</code>) is not defined for a build target, it is not present in the output.<br /><br />Multiple attributes may be specified by providing the --output-attribute option multiple times.<br /><br />NOTE: The primary difference between this and --output-attributes is that --output-attribute works correctly with other multiple-argument queries. Example:</p><p><pre class="prettyprint lang-py">
$ buck query '//example/...' --output-attribute buck.type --output-attribute name --output-attribute srcs
{
  "//example/foo:bar" : {
    "buck.type" : "cxx_library",
    "name" : "foobar",
    "srcs" : [ "example/foo/bar.cc", "example/foo/lib/lib.cc" ]
  }
  "//example/foo:main" : {
    "buck.type" : "cxx_binary",
    "name" : "main"
  }
}
</pre></p></div></ul><h2>Examples</h2><pre class="prettyprint lang-py">
#
# For the following examples, assume this BUCK file exists in
# the `examples` directory.
#
cxx_library(
  name = 'one',
  srcs = [ '1.cpp' ],
  deps = [
    ':two',
    ':three',
  ],
)

cxx_library(
  name = 'two',
  srcs = [ '2.cpp' ],
  deps = [
    ':four',
  ],
  tests = [ ':two-tests' ]
)

cxx_library(
  name = 'three',
  srcs = [ '3.cpp' ],
  deps = [
    ':four',
    ':five',
  ],
  tests = [ ':three-tests' ],
)

cxx_library(
  name = 'four',
  srcs = [ '4.cpp' ],
  deps = [
    ':five',
  ]
)

cxx_library(
  name = 'five',
  srcs = [ '5.cpp' ],
)

cxx_test(
  name = 'two-tests',
  srcs = [ '2-test.cpp' ],
  deps = [ ':two' ],
)

cxx_test(
  name = 'three-tests',
  srcs = [ '3-test.cpp' ],
  deps = [ ':three' ],
)
</pre><p><b>Example</b>: List <em>all</em> the targets in the repository.</p><p><pre>buck query "//..."</pre><pre>
//examples:five
//examples:four
//examples:one
//examples:three
//examples:three-tests
//examples:two
//examples:two-tests
</pre></p><p><b>Example</b>: Resolve multiple aliases.</p><p>Suppose <code>.buckconfig</code> contains the following aliases:</p><p><pre>
app = //apps/myapp:app
lib = //libraries/mylib:lib
</pre></p><p>Then the following query</p><p><pre>
buck query "%s" app lib --json
</pre></p><p>returns</p><pre class="prettyprint lang-js">
{
  "app": ["//apps/myapp:app"],
  "lib": ["//libraries/mylib:lib"]
}
</pre></p><p><b>Example</b>: List all of the targets on which the <code>one</code> library <em>directly</em> depends.</p><p><pre>
$ buck query "deps(//examples:one, 1)"
//examples:one
//examples:three
//examples:two
</pre></p><p><b>Example</b>: Display a JSON representation of the transitive closure of the targets on which the <code>one</code> library depends.</p><p><pre>
$ buck query "deps(//examples:one)"
[
  "//examples:five",
  "//examples:four",
  "//examples:one",
  "//examples:three",
  "//examples:two"
]
</pre></p><p><b>Example</b>: Display a JSON representation of the tests associated with the  <code>one</code> and <code>three</code> libraries.</p><p><pre>
$ buck query --json "testsof(deps('%s'))" //examples:one //examples:three
{
  "//examples:one": ["//examples:two-tests"],
  "//examples:three": ["//examples:three-tests"]
}
</pre></p><p><b>Example</b>: Display the build file that contains the target which is the owner of the source file, <code>examples/1.cpp</code>.</p><p><pre>
$ buck query "buildfile(owner('examples/1.cpp'))"
example/BUCK
</pre></p></div></article><nav><h3>The Basics</h3><ul><li class=""><a href="/setup/getting_started.html">Getting Started</a></li><li class=""><a href="/about/overview.html">Key Concepts</a></li><li class=""><a href="/learning/tutorial.html">Tutorial</a></li><li class=""><a href="/setup/intellij_plugin_install.html">Installing the IntelliJ Plugin</a></li><li class=""><a href="/article/exopackage.html">Exopackage</a></li><li class=""><a href="/article/query_cheat_sheet.html">Buck Query Cheat Sheet</a></li></ul><h3>About</h3><ul><li class=""><a href="/concept/what_makes_buck_so_fast.html">What Makes Buck so Fast?</a></li><li class=""><a href="/about/showcase.html">Showcase</a></li><li class=""><a href="/concept/troubleshooting.html">Troubleshooting</a></li><li class=""><a href="/about/performance_tuning.html">Performance Tuning</a></li><li class=""><a href="/concept/faq.html">FAQ</a></li><li class=""><a href="/presentations/index.html">Learn More (Buck Presentations)</a></li></ul><h3>Concepts</h3><ul><li class=""><a href="/concept/build_rule.html">Build Rule</a></li><li class=""><a href="/concept/build_file.html">Build File</a></li><li class=""><a href="/concept/build_target.html">Build Target</a></li><li class=""><a href="/concept/build_target_pattern.html">Build Target Pattern</a></li><li class=""><a href="/concept/buckd.html">Buck Daemon (buckd)</a></li><li class=""><a href="/concept/visibility.html">Visibility</a></li><li class=""><a href="/concept/http_cache_api.html">HTTP Cache API</a></li><li class=""><a href="/concept/rule_keys.html">Rule Keys</a></li><li class=""><a href="/concept/java_abis.html">Java ABIs</a></li><li class=""><a href="/concept/skylark.html">Skylark</a></li></ul><h3>Files and Directories</h3><ul><li class=""><a href="/files-and-dirs/buckconfig.html">.buckconfig</a></li><li class=""><a href="/files-and-dirs/buckjavaargs.html">.buckjavaargs</a></li><li class=""><a href="/files-and-dirs/buck-out.html">buck-out</a></li></ul><h3>Commands</h3><ul><li class=""><a href="/command/common_parameters.html">Common Parameters</a></li><li class=""><a href="/command/audit.html">buck audit</a></li><li class=""><a href="/command/build.html">buck build</a></li><li class=""><a href="/command/clean.html">buck clean</a></li><li class=""><a href="/command/doctor.html">buck doctor</a></li><li class=""><a href="/command/fetch.html">buck fetch</a></li><li class=""><a href="/command/fix.html">buck fix</a></li><li class=""><a href="/command/install.html">buck install</a></li><li class=""><a href="/command/kill.html">buck kill</a></li><li class=""><a href="/command/killall.html">buck killall</a></li><li class=""><a href="/command/project.html">buck project</a></li><li class=""><a href="/command/publish.html">buck publish</a></li><li class="navActiveItem"><a href="/command/query.html">buck query</a></li><li class=""><a href="/command/run.html">buck run</a></li><li class=""><a href="/command/root.html">buck root</a></li><li class=""><a href="/command/server.html">buck server</a></li><li class=""><a href="/command/suggest.html">buck suggest</a></li><li class=""><a href="/command/targets.html">buck targets</a></li><li class=""><a href="/command/test.html">buck test</a></li><li class=""><a href="/command/uninstall.html">buck uninstall</a></li><li class=""><a href="/command/exit_codes.html">Exit Codes</a></li></ul><h3>Build Rules</h3><ul><li><strong>Core</strong></li><li class=""><a href="/rule/command_alias.html">command_alias()</a></li><li class=""><a href="/rule/export_file.html">export_file()</a></li><li class=""><a href="/rule/filegroup.html">filegroup()</a></li><li class=""><a href="/rule/genrule.html">genrule()</a></li><li class=""><a href="/rule/http_archive.html">http_archive()</a></li><li class=""><a href="/rule/http_file.html">http_file()</a></li><li class=""><a href="/rule/remote_file.html">remote_file()</a></li><li class=""><a href="/rule/test_suite.html">test_suite()</a></li><li class=""><a href="/rule/worker_tool.html">worker_tool()</a></li><li class=""><a href="/rule/zip_file.html">zip_file()</a></li><li><strong>Android</strong></li><li class=""><a href="/rule/android_aar.html">android_aar()</a></li><li class=""><a href="/rule/android_binary.html">android_binary()</a></li><li class=""><a href="/rule/android_build_config.html">android_build_config()</a></li><li class=""><a href="/rule/android_instrumentation_apk.html">android_instrumentation_apk()</a></li><li class=""><a href="/rule/android_instrumentation_test.html">android_instrumentation_test()</a></li><li class=""><a href="/rule/android_library.html">android_library()</a></li><li class=""><a href="/rule/android_manifest.html">android_manifest()</a></li><li class=""><a href="/rule/android_prebuilt_aar.html">android_prebuilt_aar()</a></li><li class=""><a href="/rule/android_resource.html">android_resource()</a></li><li class=""><a href="/rule/apk_genrule.html">apk_genrule()</a></li><li class=""><a href="/rule/gen_aidl.html">gen_aidl()</a></li><li class=""><a href="/rule/keystore.html">keystore()</a></li><li class=""><a href="/rule/ndk_library.html">ndk_library()</a></li><li class=""><a href="/rule/prebuilt_jar.html">prebuilt_jar()</a></li><li class=""><a href="/rule/prebuilt_native_library.html">prebuilt_native_library()</a></li><li class=""><a href="/rule/robolectric_test.html">robolectric_test()</a></li><li><strong>CXX</strong></li><li class=""><a href="/rule/cxx_binary.html">cxx_binary()</a></li><li class=""><a href="/rule/cxx_library.html">cxx_library()</a></li><li class=""><a href="/rule/cxx_genrule.html">cxx_genrule()</a></li><li class=""><a href="/rule/cxx_precompiled_header.html">cxx_precompiled_header()</a></li><li class=""><a href="/rule/cxx_test.html">cxx_test()</a></li><li class=""><a href="/rule/prebuilt_cxx_library.html">prebuilt_cxx_library()</a></li><li class=""><a href="/rule/prebuilt_cxx_library_group.html">prebuilt_cxx_library_group()</a></li><li><strong>D</strong></li><li class=""><a href="/rule/d_binary.html">d_binary()</a></li><li class=""><a href="/rule/d_library.html">d_library()</a></li><li class=""><a href="/rule/d_test.html">d_test()</a></li><li><strong>Go</strong></li><li class=""><a href="/rule/go_binary.html">go_binary()</a></li><li class=""><a href="/rule/go_library.html">go_library()</a></li><li class=""><a href="/rule/go_test.html">go_test()</a></li><li class=""><a href="/rule/cgo_library.html">cgo_library()</a></li><li><strong>Groovy</strong></li><li class=""><a href="/rule/groovy_library.html">groovy_library()</a></li><li><strong>Halide</strong></li><li class=""><a href="/rule/halide_library.html">halide_library()</a></li><li><strong>Haskell</strong></li><li class=""><a href="/rule/haskell_binary.html">haskell_binary()</a></li><li class=""><a href="/rule/haskell_library.html">haskell_library()</a></li><li class=""><a href="/rule/prebuilt_haskell_library.html">prebuilt_haskell_library()</a></li><li><strong>iOS</strong></li><li class=""><a href="/rule/apple_asset_catalog.html">apple_asset_catalog()</a></li><li class=""><a href="/rule/apple_binary.html">apple_binary()</a></li><li class=""><a href="/rule/apple_bundle.html">apple_bundle()</a></li><li class=""><a href="/rule/apple_library.html">apple_library()</a></li><li class=""><a href="/rule/apple_package.html">apple_package()</a></li><li class=""><a href="/rule/apple_resource.html">apple_resource()</a></li><li class=""><a href="/rule/apple_test.html">apple_test()</a></li><li class=""><a href="/rule/core_data_model.html">core_data_model()</a></li><li class=""><a href="/rule/prebuilt_apple_framework.html">prebuilt_apple_framework()</a></li><li><strong>Java</strong></li><li class=""><a href="/rule/java_binary.html">java_binary()</a></li><li class=""><a href="/rule/java_library.html">java_library()</a></li><li class=""><a href="/rule/java_test.html">java_test()</a></li><li class=""><a href="/rule/prebuilt_jar.html">prebuilt_jar()</a></li><li class=""><a href="/rule/prebuilt_native_library.html">prebuilt_native_library()</a></li><li><strong>Kotlin</strong></li><li class=""><a href="/rule/kotlin_library.html">kotlin_library()</a></li><li class=""><a href="/rule/kotlin_test.html">kotlin_test()</a></li><li><strong>Lua</strong></li><li class=""><a href="/rule/cxx_lua_extension.html">cxx_lua_extension()</a></li><li class=""><a href="/rule/lua_binary.html">lua_binary()</a></li><li class=""><a href="/rule/lua_library.html">lua_library()</a></li><li><strong>OCaml</strong></li><li class=""><a href="/rule/ocaml_binary.html">ocaml_binary()</a></li><li class=""><a href="/rule/ocaml_library.html">ocaml_library()</a></li><li><strong>Python</strong></li><li class=""><a href="/rule/prebuilt_python_library.html">prebuilt_python_library()</a></li><li class=""><a href="/rule/python_binary.html">python_binary()</a></li><li class=""><a href="/rule/python_library.html">python_library()</a></li><li class=""><a href="/rule/python_test.html">python_test()</a></li><li><strong>Rust</strong></li><li class=""><a href="/rule/rust_binary.html">rust_binary()</a></li><li class=""><a href="/rule/rust_library.html">rust_library()</a></li><li class=""><a href="/rule/rust_test.html">rust_test()</a></li><li class=""><a href="/rule/prebuilt_rust_library.html">prebuilt_rust_library()</a></li><li><strong>Shell</strong></li><li class=""><a href="/rule/sh_binary.html">sh_binary()</a></li><li class=""><a href="/rule/sh_test.html">sh_test()</a></li><li><strong>.NET</strong></li><li class=""><a href="/rule/csharp_library.html">csharp_library()</a></li><li class=""><a href="/rule/prebuilt_dotnet_library.html">prebuilt_dotnet_library()</a></li></ul><h3>Functions</h3><ul><li><strong>Python DSL</strong></li><li class=""><a href="/function/add_build_file_dep.html">add_build_file_dep()</a></li><li class=""><a href="/function/allow_unsafe_import.html">allow_unsafe_import()</a></li><li class=""><a href="/function/flatten_dicts.html">flatten_dicts()</a></li><li class=""><a href="/function/glob.html">glob()</a></li><li class=""><a href="/function/get_base_path.html">get_base_path()</a></li><li class=""><a href="/function/get_cell_name.html">get_cell_name()</a></li><li class=""><a href="/function/host_info.html">host_info()</a></li><li class=""><a href="/function/include_defs.html">include_defs()</a></li><li class=""><a href="/function/load.html">load()</a></li><li class=""><a href="/function/read_config.html">read_config()</a></li><li class=""><a href="/function/subdir_glob.html">subdir_glob()</a></li><li class=""><a href="/function/string_parameter_macros.html">String Parameter Macros</a></li></ul><ul><li><strong>Skylark</strong></li><li class=""><a href="/skylark/generated/glob.html">glob()</a></li><li class=""><a href="/skylark/generated/host_info.html">host_info()</a></li><li class=""><a href="/skylark/generated/package_name.html">package_name()</a></li><li class=""><a href="/skylark/generated/provider.html">provider()</a></li><li class=""><a href="/skylark/generated/read_config.html">read_config()</a></li><li class=""><a href="/skylark/generated/repository_name.html">repository_name()</a></li><li class=""><a href="/skylark/generated/rule_exists.html">rule_exists()</a></li></ul><h3>Extending Buck</h3><ul><li class=""><a href="/extending/macros.html">Custom Macros</a></li><li class=""><a href="/extending/rules.html">Custom Rules</a></li><li class=""><a href="/extending/e2e_tests.html">Building E2E Tests for Buck</a></li></ul></nav></div></section><footer><div class='width'>&copy; Copyright Facebook, 2013 - 2018</div></footer><!-- Algolia Search Code --><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
docsearch({
  apiKey: 'c25b7174e8f6161ce5fdd44bb0b95081',
  indexName: 'buckbuild',
  inputSelector: '#algolia-doc-search',
  debug: false // Set debug to true if you want to inspect the dropdown
});
</script><!-- End Algolia Search Code --><script src="/google-code-prettify/prettify.js"></script><script>prettyPrint()</script></body></html>